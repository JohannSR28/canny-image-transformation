<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canny Camera (No Backend)</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  </head>

  <body class="min-h-screen bg-zinc-950 text-zinc-100">
    <div class="max-w-5xl mx-auto px-4 py-8">
      <!-- Minimal top bar -->
      <div class="flex items-center justify-between gap-4 mb-4">
        <h1 class="text-xl font-semibold">Canny Camera</h1>
        <div class="flex gap-2">
          <button id="startBtn"
            class="rounded-2xl bg-white text-zinc-950 font-semibold px-4 py-2 hover:bg-zinc-200 transition disabled:opacity-50 disabled:cursor-not-allowed">
            Start
          </button>
          <button id="stopBtn"
            class="rounded-2xl border border-zinc-800 px-4 py-2 hover:bg-zinc-900 transition disabled:opacity-50 disabled:cursor-not-allowed">
            Stop
          </button>
        </div>
      </div>

      <!-- Output -->
      <div class="rounded-2xl border border-zinc-800 bg-zinc-900/40 p-3">
        <div class="aspect-video rounded-2xl border border-zinc-800 bg-zinc-950/40 flex items-center justify-center overflow-hidden">
          <canvas id="outCanvas" class="block"></canvas>
        </div>

        <!-- Controls -->
        <div class="mt-4 grid md:grid-cols-3 gap-4">
          <div>
            <label class="text-sm text-zinc-300">Low: <span id="lowVal">80</span></label>
            <input id="low" type="range" min="0" max="255" value="80" class="w-full" />
          </div>

          <div>
            <label class="text-sm text-zinc-300">High: <span id="highVal">180</span></label>
            <input id="high" type="range" min="0" max="255" value="180" class="w-full" />
          </div>

          <div>
            <label class="text-sm text-zinc-300">Blur: <span id="blurVal">5</span></label>
            <input id="blur" type="range" min="1" max="21" step="2" value="5" class="w-full" />
            <p class="text-xs text-zinc-500 mt-1">Impairs uniquement (1,3,5…)</p>
          </div>
        </div>

        <div class="mt-3 flex items-center justify-between gap-3">
          <p id="status" class="text-sm text-zinc-400">Chargement OpenCV…</p>

          <div class="flex items-center gap-2">
            <label class="text-sm text-zinc-300 flex items-center gap-2 cursor-pointer select-none">
              <input id="invert" type="checkbox" class="scale-110" />
              Inverser (traits noirs sur fond blanc)
            </label>

            <label class="text-sm text-zinc-300 flex items-center gap-2 cursor-pointer select-none">
              <input id="hq" type="checkbox" class="scale-110" />
              HQ (plus lourd)
            </label>
          </div>
        </div>
      </div>

      <!-- Hidden video + input canvas -->
      <video id="video" class="hidden" playsinline></video>
      <canvas id="inCanvas" class="hidden"></canvas>
    </div>

    <script>
      // Elements
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const statusEl = document.getElementById("status");

      const low = document.getElementById("low");
      const high = document.getElementById("high");
      const blur = document.getElementById("blur");
      const lowVal = document.getElementById("lowVal");
      const highVal = document.getElementById("highVal");
      const blurVal = document.getElementById("blurVal");

      const invert = document.getElementById("invert");
      const hq = document.getElementById("hq");

      const video = document.getElementById("video");
      const inCanvas = document.getElementById("inCanvas");
      const outCanvas = document.getElementById("outCanvas");

      // State
      let cvReady = false;
      let stream = null;
      let running = false;

      // Update labels
      low.addEventListener("input", () => (lowVal.textContent = low.value));
      high.addEventListener("input", () => (highVal.textContent = high.value));
      blur.addEventListener("input", () => (blurVal.textContent = blur.value));

      // OpenCV ready polling
      function waitForCV() {
        if (typeof cv !== "undefined" && cv.Mat) {
          cvReady = true;
          statusEl.textContent = "Prêt ✅";
          startBtn.disabled = false;
          stopBtn.disabled = true;
          return;
        }
        setTimeout(waitForCV, 100);
      }

      startBtn.disabled = true;
      stopBtn.disabled = true;
      waitForCV();

      // Helpers
      function pickConstraints() {
        // "HQ" = plus grand (plus lourd), sinon plus léger (plus fluide)
        if (hq.checked) {
          return { video: { facingMode: "user", width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false };
        }
        return { video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 360 } }, audio: false };
      }

      async function startCamera() {
        if (!cvReady) return (statusEl.textContent = "Chargement OpenCV…");
        if (running) return;

        statusEl.textContent = "Demande caméra…";

        try {
          stream = await navigator.mediaDevices.getUserMedia(pickConstraints());
          video.srcObject = stream;

          await video.play();

          // Set canvas sizes to match video
          const vw = video.videoWidth || 640;
          const vh = video.videoHeight || 360;

          inCanvas.width = vw;
          inCanvas.height = vh;

          outCanvas.width = vw;
          outCanvas.height = vh;

          running = true;
          startBtn.disabled = true;
          stopBtn.disabled = false;
          statusEl.textContent = "Live ✅";

          renderLoop();
        } catch (e) {
          statusEl.textContent = "Caméra refusée / indisponible";
          running = false;
          startBtn.disabled = false;
          stopBtn.disabled = true;
        }
      }

      function stopCamera() {
        running = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        // Clear output canvas
        const ctx = outCanvas.getContext("2d");
        ctx.clearRect(0, 0, outCanvas.width, outCanvas.height);

        statusEl.textContent = cvReady ? "Prêt ✅" : "Chargement OpenCV…";
      }

      // Main loop
      function renderLoop() {
        if (!running) return;

        const ctx = inCanvas.getContext("2d", { willReadFrequently: true });
        ctx.drawImage(video, 0, 0, inCanvas.width, inCanvas.height);

        // thresholds safety
        const lowT = Math.min(parseInt(low.value, 10), parseInt(high.value, 10));
        const highT = Math.max(parseInt(low.value, 10), parseInt(high.value, 10));
        const k = parseInt(blur.value, 10);

        try {
          // Read frame into OpenCV
          const src = cv.imread(inCanvas); // RGBA
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

          const blurred = new cv.Mat();
          cv.GaussianBlur(gray, blurred, new cv.Size(k, k), 0);

          const edges = new cv.Mat();
          cv.Canny(blurred, edges, lowT, highT);

          if (invert.checked) {
            cv.bitwise_not(edges, edges);
          }

          // Show
          cv.imshow(outCanvas, edges);

          // Cleanup
          src.delete();
          gray.delete();
          blurred.delete();
          edges.delete();
        } catch (e) {
          // If something happens, stop loop gracefully
          statusEl.textContent = "Erreur traitement";
          stopCamera();
          return;
        }

        // Aim ~30fps if not HQ (simple throttle)
        if (!hq.checked) {
          setTimeout(() => requestAnimationFrame(renderLoop), 33);
        } else {
          requestAnimationFrame(renderLoop);
        }
      }

      // UI events
      startBtn.addEventListener("click", startCamera);
      stopBtn.addEventListener("click", stopCamera);

      // If user toggles HQ while running, restart for new constraints
      hq.addEventListener("change", async () => {
        if (!running) return;
        stopCamera();
        await startCamera();
      });
    </script>
  </body>
</html>
