<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canny (sans backend)</title>

    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- OpenCV.js CDN (WASM) -->
    <!-- Si jamais ce CDN change dans le futur, cherche "opencv.js wasm CDN" et remplace l'URL -->
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  </head>

  <body class="min-h-screen bg-zinc-950 text-zinc-100">
    <div class="max-w-5xl mx-auto px-4 py-10">
      <header class="mb-8">
        <h1 class="text-3xl font-semibold tracking-tight">Canny — Photo → Traits (noir & blanc) (100% front)</h1>
        <p class="text-zinc-300 mt-2">
          Aucun serveur. Tout tourne dans ton navigateur via OpenCV.js.
        </p>
      </header>

      <!-- HERO EXPLICATION -->
<section class="mb-8 rounded-2xl border border-zinc-800 bg-zinc-900/40 p-6">
  <div class="flex flex-col gap-3">
    <h2 class="text-2xl font-semibold">
      Pas besoin d’écrire : tout tourne dans ton navigateur
    </h2>

    <p class="text-zinc-300">
      Tu n’as rien à installer, aucun serveur, aucune API. Tu mets une image, tu cliques “Générer”, et tu obtiens
      la version <span class="font-semibold text-white">Canny</span> (traits ressortis en noir & blanc).
    </p>

    <div class="rounded-2xl border border-zinc-800 bg-zinc-950/40 p-4">
      <p class="text-sm text-zinc-400 mb-1">Explication (style ChatGPT)</p>
      <p class="text-zinc-200">
        « Donne une image telle… et transforme-la en telle :
        <span class="font-semibold">Canny</span> (contours/traits en noir & blanc). »
      </p>
    </div>

    <div class="flex flex-wrap gap-2 pt-1">
      <span class="px-3 py-1 rounded-full text-sm bg-zinc-800 text-zinc-200">1) Upload une image</span>
      <span class="px-3 py-1 rounded-full text-sm bg-zinc-800 text-zinc-200">2) Ajuste les seuils</span>
      <span class="px-3 py-1 rounded-full text-sm bg-zinc-800 text-zinc-200">3) Génère & télécharge</span>
    </div>
  </div>
</section>


      <div class="grid md:grid-cols-2 gap-6">
        <!-- LEFT -->
        <section class="rounded-2xl bg-zinc-900/60 border border-zinc-800 p-5">
          <h2 class="text-lg font-medium mb-4">Entrée</h2>

          <div class="flex items-center gap-3">
            <input id="file" type="file" accept="image/*"
              class="block w-full text-sm file:mr-4 file:rounded-xl file:border-0 file:bg-zinc-800 file:px-4 file:py-2 file:text-zinc-100 hover:file:bg-zinc-700 cursor-pointer" />
          </div>

          <div class="mt-4 rounded-2xl border border-zinc-800 bg-zinc-950/40 p-3">
            <p class="text-sm text-zinc-400 mb-2">Status</p>
            <p id="status" class="text-sm text-zinc-200">Chargement d’OpenCV…</p>
          </div>

          <div class="mt-5 space-y-4">
            <div>
              <label class="text-sm text-zinc-300">Low threshold: <span id="lowVal">80</span></label>
              <input id="low" type="range" min="0" max="255" value="80" class="w-full" />
            </div>
            <div>
              <label class="text-sm text-zinc-300">High threshold: <span id="highVal">180</span></label>
              <input id="high" type="range" min="0" max="255" value="180" class="w-full" />
            </div>

            <div>
              <label class="text-sm text-zinc-300">Blur (anti-bruit): <span id="blurVal">5</span>×<span id="blurVal2">5</span></label>
              <input id="blur" type="range" min="1" max="21" step="2" value="5" class="w-full" />
              <p class="text-xs text-zinc-500 mt-1">Valeurs impaires seulement (1,3,5…)</p>
            </div>

            <div class="flex gap-3">
              <button id="btn"
                class="flex-1 rounded-2xl bg-white text-zinc-950 font-semibold py-3 hover:bg-zinc-200 transition disabled:opacity-50 disabled:cursor-not-allowed">
                Générer
              </button>
              <button id="reset"
                class="flex-1 rounded-2xl border border-zinc-800 py-3 hover:bg-zinc-900 transition">
                Reset
              </button>
            </div>
          </div>

          <div class="mt-6">
            <p class="text-sm text-zinc-300 mb-2">Aperçu (original)</p>
            <img id="preview" class="w-full rounded-2xl border border-zinc-800 bg-zinc-950/40 hidden" alt="preview" />
          </div>
        </section>

        <!-- RIGHT -->
        <section class="rounded-2xl bg-zinc-900/60 border border-zinc-800 p-5">
          <h2 class="text-lg font-medium mb-4">Sortie (traits)</h2>

          <div class="aspect-video rounded-2xl border border-zinc-800 bg-zinc-950/40 flex items-center justify-center overflow-hidden">
            <canvas id="canvasOut" class="hidden"></canvas>
            <p id="placeholder" class="text-zinc-500 text-sm">La sortie apparaîtra ici</p>
          </div>

          <div class="mt-4 flex gap-3">
            <a id="download"
              class="hidden flex-1 text-center rounded-2xl bg-zinc-800 py-3 hover:bg-zinc-700 transition"
              download="canny.png">Télécharger PNG</a>

            <button id="fit"
              class="flex-1 rounded-2xl border border-zinc-800 py-3 hover:bg-zinc-900 transition">
              Fit to box
            </button>
          </div>

          <!-- Canvas input caché -->
          <canvas id="canvasIn" class="hidden"></canvas>
        </section>
      </div>
    </div>

    <script>
      const fileInput = document.getElementById("file");
      const preview = document.getElementById("preview");
      const statusEl = document.getElementById("status");

      const low = document.getElementById("low");
      const high = document.getElementById("high");
      const blur = document.getElementById("blur");
      const lowVal = document.getElementById("lowVal");
      const highVal = document.getElementById("highVal");
      const blurVal = document.getElementById("blurVal");
      const blurVal2 = document.getElementById("blurVal2");

      const btn = document.getElementById("btn");
      const reset = document.getElementById("reset");
      const fit = document.getElementById("fit");

      const canvasIn = document.getElementById("canvasIn");
      const canvasOut = document.getElementById("canvasOut");
      const placeholder = document.getElementById("placeholder");
      const download = document.getElementById("download");

      let opencvReady = false;
      let imgLoaded = false;
      let lastOutDataUrl = null;

      low.addEventListener("input", () => lowVal.textContent = low.value);
      high.addEventListener("input", () => highVal.textContent = high.value);
      blur.addEventListener("input", () => {
        blurVal.textContent = blur.value;
        blurVal2.textContent = blur.value;
      });

      // OpenCV init hook
      function waitForOpenCV() {
        // opencv.js expose souvent cv via global 'cv'
        if (typeof cv !== "undefined" && cv.Mat) {
          opencvReady = true;
          statusEl.textContent = "OpenCV prêt ✅";
          btn.disabled = false;
          return;
        }
        setTimeout(waitForOpenCV, 100);
      }

      btn.disabled = true;
      waitForOpenCV();

      fileInput.addEventListener("change", async () => {
        const f = fileInput.files?.[0];
        if (!f) return;

        imgLoaded = false;

        const url = URL.createObjectURL(f);
        preview.src = url;
        preview.classList.remove("hidden");

        // Dessiner l'image dans canvasIn à une taille raisonnable pour perf
        const img = new Image();
        img.onload = () => {
          const MAX_W = 1600; // évite de cramer le navigateur sur très grosses images
          const scale = Math.min(1, MAX_W / img.width);
          const w = Math.round(img.width * scale);
          const h = Math.round(img.height * scale);

          canvasIn.width = w;
          canvasIn.height = h;
          const ctx = canvasIn.getContext("2d");
          ctx.clearRect(0, 0, w, h);
          ctx.drawImage(img, 0, 0, w, h);

          imgLoaded = true;
          statusEl.textContent = `Image chargée (${w}×${h}).`;
        };
        img.src = url;
      });

      reset.addEventListener("click", () => {
        fileInput.value = "";
        preview.classList.add("hidden");
        statusEl.textContent = opencvReady ? "OpenCV prêt ✅" : "Chargement d’OpenCV…";

        imgLoaded = false;
        lastOutDataUrl = null;

        canvasOut.classList.add("hidden");
        placeholder.classList.remove("hidden");
        download.classList.add("hidden");
      });

      fit.addEventListener("click", () => {
        // fit canvas dans la box aspect-video (simple: max-width:100%)
        canvasOut.style.maxWidth = "100%";
        canvasOut.style.maxHeight = "100%";
      });

      btn.addEventListener("click", () => {
        if (!opencvReady) {
          statusEl.textContent = "OpenCV pas prêt (attends 1-2 sec).";
          return;
        }
        if (!imgLoaded) {
          statusEl.textContent = "Choisis une image d’abord.";
          return;
        }

        // sécurise low/high
        const lowT = Math.min(parseInt(low.value, 10), parseInt(high.value, 10));
        const highT = Math.max(parseInt(low.value, 10), parseInt(high.value, 10));
        const k = parseInt(blur.value, 10);

        btn.disabled = true;
        statusEl.textContent = "Traitement…";

        try {
          // Lire pixels depuis canvasIn → Mat
          const src = cv.imread(canvasIn); // RGBA
          const gray = new cv.Mat();
          cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

          // Blur optionnel
          const blurred = new cv.Mat();
          const ksize = new cv.Size(k, k);
          cv.GaussianBlur(gray, blurred, ksize, 0, 0, cv.BORDER_DEFAULT);

          // Canny
          const edges = new cv.Mat();
          cv.Canny(blurred, edges, lowT, highT);

          // Écrire résultat dans canvasOut
          canvasOut.width = edges.cols;
          canvasOut.height = edges.rows;
          cv.imshow(canvasOut, edges);

          // UI
          canvasOut.classList.remove("hidden");
          placeholder.classList.add("hidden");

          // Download
          lastOutDataUrl = canvasOut.toDataURL("image/png");
          download.href = lastOutDataUrl;
          download.classList.remove("hidden");

          statusEl.textContent = `Done ✅ (low=${lowT}, high=${highT}, blur=${k}×${k})`;

          // cleanup
          src.delete();
          gray.delete();
          blurred.delete();
          edges.delete();
        } catch (e) {
          statusEl.textContent = "Erreur: " + (e?.message ?? e);
        } finally {
          btn.disabled = false;
        }
      });
    </script>
  </body>
</html>
